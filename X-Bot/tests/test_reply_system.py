#!/usr/bin/env python3
"""
Test complet du syst√®me de gestion des r√©ponses aux tweets

Ce test couvre :
- D√©tection des nouvelles r√©ponses
- Gestion des duplicatas
- Auto-like des r√©ponses
- Stockage et r√©cup√©ration
- V√©rifications de startup
- Performance et optimisations
"""

import sys
import os
import time
from pathlib import Path
from datetime import datetime, timedelta
from unittest.mock import MagicMock, patch

# Ajouter le dossier core au PATH
current_dir = Path(__file__).parent.parent
core_dir = current_dir / "core"
config_dir = current_dir / "config"

sys.path.insert(0, str(core_dir))
sys.path.insert(0, str(config_dir))

from storage import StorageManager, Reply, Tweet
from reply_handler import ReplyHandler
from config import get_config_manager


class TestReplySystem:
    """Test complet du syst√®me de r√©ponses"""
    
    def __init__(self):
        self.storage_manager = None
        self.reply_handler = None
        self.test_data = {}
        
    def setup(self):
        """Initialisation des tests"""
        print("üîß Initialisation des tests...")
        
        try:
            self.storage_manager = StorageManager()
            self.reply_handler = ReplyHandler()
            
            # Cr√©er des donn√©es de test
            self.test_data = {
                'test_tweet': Tweet(
                    tweet_id="test_tweet_123456",
                    content="Test tweet pour les r√©ponses",
                    posted_at=datetime.utcnow()
                ),
                'test_replies': [
                    Reply(
                        reply_id="reply_001",
                        original_tweet_id="test_tweet_123456",
                        author_id="user_001",
                        content="Premi√®re r√©ponse de test",
                        created_at=datetime.utcnow(),
                        liked=False
                    ),
                    Reply(
                        reply_id="reply_002",
                        original_tweet_id="test_tweet_123456",
                        author_id="user_002",
                        content="Deuxi√®me r√©ponse de test",
                        created_at=datetime.utcnow(),
                        liked=False
                    ),
                    Reply(
                        reply_id="reply_003",
                        original_tweet_id="test_tweet_123456",
                        author_id="user_003",
                        content="Troisi√®me r√©ponse de test",
                        created_at=datetime.utcnow(),
                        liked=True
                    )
                ]
            }
            
            print("‚úÖ Initialisation r√©ussie")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur d'initialisation : {e}")
            return False
    
    def test_duplicate_detection(self):
        """Test de d√©tection des duplicatas"""
        print("\nüîç Test D√©tection des Duplicatas")
        print("=" * 40)
        
        try:
            test_reply = self.test_data['test_replies'][0]
            
            # 1. Premier enregistrement
            print("1. Premier enregistrement...")
            result1 = self.storage_manager.save_reply(test_reply)
            print(f"   ‚úÖ Enregistr√© avec ID: {result1}")
            
            # 2. Tentative de duplicate
            print("2. Tentative de duplicate...")
            result2 = self.storage_manager.save_reply(test_reply)
            print(f"   ‚úÖ Duplicate g√©r√©, ID retourn√©: {result2}")
            
            # 3. V√©rification d'existence
            print("3. V√©rification d'existence...")
            exists = self.storage_manager.reply_exists(test_reply.reply_id)
            print(f"   ‚úÖ R√©ponse existe: {exists}")
            
            # 4. Test de batch check
            print("4. Test v√©rification en lot...")
            reply_ids = [r.reply_id for r in self.test_data['test_replies']]
            existing_ids = self.storage_manager.get_existing_reply_ids(reply_ids)
            print(f"   ‚úÖ IDs existants trouv√©s: {len(existing_ids)}")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur test duplicatas : {e}")
            return False
    
    def test_reply_processing(self):
        """Test du traitement des r√©ponses"""
        print("\n‚öôÔ∏è Test Traitement des R√©ponses")
        print("=" * 40)
        
        try:
            # Sauvegarder toutes les r√©ponses de test
            print("1. Sauvegarde des r√©ponses de test...")
            saved_count = 0
            for reply in self.test_data['test_replies']:
                result = self.storage_manager.save_reply(reply)
                if result:
                    saved_count += 1
            
            print(f"   ‚úÖ {saved_count} r√©ponses sauvegard√©es")
            
            # Test de r√©cup√©ration
            print("2. R√©cup√©ration des r√©ponses r√©centes...")
            recent_replies = self.storage_manager.get_recent_replies(hours=1)
            print(f"   ‚úÖ {len(recent_replies)} r√©ponses r√©cup√©r√©es")
            
            # Test de v√©rification d'existence
            print("3. Test de v√©rification d'existence...")
            for reply in self.test_data['test_replies']:
                exists = self.storage_manager.reply_exists(reply.reply_id)
                print(f"   {'‚úÖ' if exists else '‚ùå'} {reply.reply_id}: {exists}")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur traitement r√©ponses : {e}")
            return False
    
    def test_auto_like_system(self):
        """Test du syst√®me d'auto-like"""
        print("\n‚ù§Ô∏è Test Syst√®me Auto-Like")
        print("=" * 40)
        
        try:
            # Mock du Twitter manager pour √©viter les vrais appels API
            with patch('reply_handler.get_twitter_manager') as mock_twitter:
                mock_twitter_instance = MagicMock()
                mock_twitter_instance.like_tweet.return_value = True
                mock_twitter.return_value = mock_twitter_instance
                
                # Test de la fonction auto-like
                print("1. Test auto-like d'une r√©ponse...")
                reply_id = "test_reply_like_001"
                result = self.reply_handler._auto_like_reply(reply_id)
                print(f"   ‚úÖ Auto-like r√©sultat: {result}")
                
                # V√©rifier que la m√©thode like_tweet a √©t√© appel√©e
                mock_twitter_instance.like_tweet.assert_called_with(reply_id)
                print("   ‚úÖ Appel API Twitter confirm√©")
                
                return True
                
        except Exception as e:
            print(f"‚ùå Erreur test auto-like : {e}")
            return False
    
    def test_startup_check(self):
        """Test du syst√®me de v√©rification au d√©marrage"""
        print("\nüöÄ Test V√©rification Startup")
        print("=" * 40)
        
        try:
            # Simuler un tweet sauvegard√©
            test_tweet = self.test_data['test_tweet']
            saved_tweet_id = self.storage_manager.save_tweet(test_tweet)
            
            if saved_tweet_id:
                print("   ‚úÖ Tweet de test sauvegard√©")
            
            # Test du startup check
            print("1. Test startup check...")
            
            # Mock du Twitter manager pour √©viter les vrais appels API
            with patch('reply_handler.get_twitter_manager') as mock_twitter:
                mock_twitter_instance = MagicMock()
                mock_twitter_instance.get_tweet_replies.return_value = []
                mock_twitter.return_value = mock_twitter_instance
                
                # Forcer un startup check
                result = self.reply_handler.force_startup_check()
                print(f"   ‚úÖ Startup check r√©sultat: {result}")
                
                # V√©rifier les statistiques
                stats = self.reply_handler.get_reply_stats()
                print(f"   ‚úÖ Statistiques: {stats}")
                
                return True
                
        except Exception as e:
            print(f"‚ùå Erreur test startup : {e}")
            return False
    
    def test_performance_optimization(self):
        """Test des optimisations de performance"""
        print("\n‚ö° Test Optimisations Performance")
        print("=" * 40)
        
        try:
            # Test de v√©rification en lot
            print("1. Test v√©rification en lot...")
            
            # Cr√©er plusieurs IDs de test
            test_ids = [f"perf_test_{i}" for i in range(20)]
            
            # Sauvegarder quelques r√©ponses
            for i in range(5):
                test_reply = Reply(
                    reply_id=test_ids[i],
                    original_tweet_id="perf_tweet_123",
                    author_id=f"user_{i}",
                    content=f"R√©ponse performance test {i}",
                    created_at=datetime.utcnow()
                )
                self.storage_manager.save_reply(test_reply)
            
            # Test de r√©cup√©ration en lot
            start_time = time.time()
            existing_ids = self.storage_manager.get_existing_reply_ids(test_ids)
            end_time = time.time()
            
            print(f"   ‚úÖ V√©rification de {len(test_ids)} IDs en {end_time - start_time:.3f}s")
            print(f"   ‚úÖ {len(existing_ids)} IDs existants trouv√©s")
            
            # Test de cache m√©moire
            print("2. Test cache m√©moire...")
            cache_size = len(self.reply_handler._processed_replies)
            print(f"   ‚úÖ Cache contient {cache_size} r√©ponses")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur test performance : {e}")
            return False
    
    def test_real_world_scenario(self):
        """Test d'un sc√©nario r√©el complet"""
        print("\nüåç Test Sc√©nario R√©el")
        print("=" * 40)
        
        try:
            # Simuler un flux de travail complet
            print("1. Simulation d'un flux complet...")
            
            # Mock des managers
            with patch('reply_handler.get_twitter_manager') as mock_twitter, \
                 patch('reply_handler.get_config_manager') as mock_config:
                
                # Configuration du mock
                mock_twitter_instance = MagicMock()
                mock_twitter_instance.get_tweet_replies.return_value = self.test_data['test_replies']
                mock_twitter_instance.like_tweet.return_value = True
                mock_twitter.return_value = mock_twitter_instance
                
                mock_config_instance = MagicMock()
                mock_config_instance.get_config.return_value = MagicMock(
                    engagement=MagicMock(
                        auto_like_replies=True,
                        auto_reply_enabled=False
                    )
                )
                mock_config.return_value = mock_config_instance
                
                # Simuler le traitement
                result = self.reply_handler.check_and_handle_replies()
                print(f"   ‚úÖ Traitement termin√©: {result}")
                
                # V√©rifier que les r√©ponses ont √©t√© trait√©es
                if 'new_replies' in result:
                    print(f"   ‚úÖ {result['new_replies']} nouvelles r√©ponses trait√©es")
                
                if 'likes_sent' in result:
                    print(f"   ‚úÖ {result['likes_sent']} likes envoy√©s")
                
                return True
                
        except Exception as e:
            print(f"‚ùå Erreur test sc√©nario r√©el : {e}")
            return False
    
    def cleanup(self):
        """Nettoyage apr√®s les tests"""
        print("\nüßπ Nettoyage des donn√©es de test...")
        
        try:
            if self.storage_manager and self.storage_manager.supabase:
                # Supprimer les donn√©es de test
                test_reply_ids = [r.reply_id for r in self.test_data['test_replies']]
                test_reply_ids.extend([f"perf_test_{i}" for i in range(20)])
                
                for reply_id in test_reply_ids:
                    try:
                        self.storage_manager.supabase.table('replies').delete().eq(
                            'reply_id', reply_id
                        ).execute()
                    except:
                        pass  # Ignorer les erreurs de suppression
                
                # Supprimer le tweet de test
                try:
                    self.storage_manager.supabase.table('tweets').delete().eq(
                        'tweet_id', self.test_data['test_tweet'].tweet_id
                    ).execute()
                except:
                    pass
                
                print("   ‚úÖ Donn√©es de test supprim√©es")
            
        except Exception as e:
            print(f"   ‚ö†Ô∏è Erreur de nettoyage : {e}")
    
    def run_all_tests(self):
        """Ex√©cuter tous les tests"""
        print("üß™ TEST COMPLET DU SYST√àME DE R√âPONSES")
        print("=" * 60)
        
        if not self.setup():
            return False
        
        tests = [
            ('D√©tection Duplicatas', self.test_duplicate_detection),
            ('Traitement R√©ponses', self.test_reply_processing),
            ('Syst√®me Auto-Like', self.test_auto_like_system),
            ('V√©rification Startup', self.test_startup_check),
            ('Optimisations Performance', self.test_performance_optimization),
            ('Sc√©nario R√©el', self.test_real_world_scenario)
        ]
        
        results = {}
        
        for test_name, test_func in tests:
            try:
                results[test_name] = test_func()
            except Exception as e:
                print(f"‚ùå Erreur dans {test_name}: {e}")
                results[test_name] = False
        
        # Nettoyage
        self.cleanup()
        
        # R√©sum√©
        print("\nüìä R√âSUM√â DES TESTS")
        print("=" * 60)
        
        passed = sum(1 for success in results.values() if success)
        total = len(results)
        
        for test_name, success in results.items():
            status = "‚úÖ PASS" if success else "‚ùå FAIL"
            print(f"{test_name}: {status}")
        
        print(f"\nüéØ R√©sultat: {passed}/{total} tests r√©ussis")
        
        if passed == total:
            print("üéâ TOUS LES TESTS R√âUSSIS !")
            print("‚úÖ Le syst√®me de r√©ponses fonctionne parfaitement")
        else:
            print("‚ö†Ô∏è  Certains tests ont √©chou√©")
            print("üîß V√©rifiez la configuration et les d√©pendances")
        
        return passed == total


def main():
    """Point d'entr√©e principal"""
    test_system = TestReplySystem()
    success = test_system.run_all_tests()
    
    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main()) 